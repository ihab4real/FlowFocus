# Error Handling in FlowFocus

## Overview

This document explains the error handling system in the server side of FlowFocus, how all components work together, and the flow from error occurrence to response.

## Components

The error handling system consists of several key components:

1. **AppError Class** - A custom error class that extends the built-in Error class with additional properties.
2. **errorTypes Factory** - A collection of functions to create common error types with predefined status codes.
3. **asyncHandler Utility** - A wrapper for async controller functions that eliminates the need for try/catch blocks.
4. **Error Middleware** - Global middleware that catches and processes all errors in the application.

## How It All Works Together

### The Error Flow

Here's what happens from the moment an error occurs to what the client receives:

1. **Error Occurrence**: An error can happen in several ways:

   - Thrown explicitly in a controller using `throw errorTypes.X()`
   - Thrown implicitly due to a programming error (e.g., accessing undefined properties)
   - Generated by Express for undefined routes
   - Generated by Mongoose for database-related issues

2. **Error Capture**:

   - For controller functions wrapped with `asyncHandler`, the error is automatically caught by the Promise.catch() mechanism
   - For middleware functions like `notFoundHandler`, errors are passed to the next middleware using `next(error)`

3. **Error Processing**: The global `errorHandler` middleware:

   - Normalizes different error types (Mongoose, JWT, etc.) into AppError instances
   - Determines if the error is operational (expected) or programming (unexpected)
   - Prepares an appropriate response based on the environment (development/production)

4. **Error Response**: The client receives a JSON response with:
   - Status code (400, 404, 500, etc.)
   - Error message
   - Additional details in development mode (stack trace, request details)

## The Magic of asyncHandler

### Traditional Approach vs. asyncHandler

#### Traditional Approach (with explicit next):

```javascript
const getUser = async (req, res, next) => {
  try {
    const user = await User.findById(req.params.id);
    if (!user) {
      return next(new AppError("User not found", 404));
    }
    res.status(200).json({ user });
  } catch (error) {
    return next(error);
  }
};
```

#### With asyncHandler (no explicit next):

```javascript
const getUser = asyncHandler(async (req, res) => {
  const user = await User.findById(req.params.id);
  if (!user) {
    throw errorTypes.notFound("User not found");
  }
  res.status(200).json({ user });
});
```

### How asyncHandler Works

The key to understanding how asyncHandler works is in its implementation:

```javascript
const asyncHandler = (fn) => {
  return (req, res, next) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
};
```

This does several important things:

1. It returns a new function that wraps your controller function
2. It executes your function and wraps the result in Promise.resolve()
3. It attaches a .catch(next) handler to the promise
4. When an error occurs, it automatically calls next(error)

This means you can simply `throw` errors in your controller functions instead of calling `next(error)`. The asyncHandler will catch these errors and pass them to the next middleware (which is eventually the errorHandler).

## Operational vs. Programming Errors

The system distinguishes between two types of errors:

- **Operational Errors**: Expected errors that occur during normal operation (e.g., invalid user input, resource not found). These are handled gracefully with appropriate status codes and messages.

- **Programming Errors**: Unexpected errors that indicate bugs in the code (e.g., trying to access properties of undefined). These are logged with full details for debugging.

## Best Practices

1. **Use errorTypes**: Instead of creating AppError instances directly, use the factory functions:

   ```javascript
   throw errorTypes.notFound("Resource not found");
   ```

2. **Let asyncHandler Handle Errors**: Don't use try/catch in controller functions wrapped with asyncHandler unless you need custom error handling logic.

3. **Be Specific**: Use the most specific error type for the situation to provide clear feedback to clients.

4. **Log Appropriately**: The error middleware handles logging, so you don't need to log errors in controllers.

## Conclusion

The error handling system in FlowFocus provides a clean, consistent way to handle errors throughout the application. By using asyncHandler and errorTypes, you can write more concise controller functions while still providing detailed error information to clients.
